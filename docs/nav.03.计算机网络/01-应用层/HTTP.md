# HTTP

<!-- TOC -->

- [HTTP](#http)
  - [请求方法包括](#请求方法包括)
  - [Get与Post](#get与post)
    - [get和post的区别](#get和post的区别)
  - [状态码](#状态码)
    - [HTTP状态码分类](#http状态码分类)
    - [HTTP状态码列表 |](#http状态码列表-)
  - [协议版本](#协议版本)
    - [Http 1.0 与 1.1区别](#http-10-与-11区别)
    - [Http1.1和Http2之间的区别](#http11和http2之间的区别)
  - [HTTPS详解](#https详解)
    - [TLS / SSL](#tls--ssl)
      - [SSL](#ssl)
      - [TLS](#tls)
    - [不加密可能存在的风险](#不加密可能存在的风险)

<!-- /TOC -->
## 请求方法包括

OPTIONS, GET, POST, HEAD, DELETE, TRACE和 Connect

## Get与Post

### get和post的区别

- get请求一般用于向服务器查询某些信息, post请求通常用于向服务器发送应该被保存的数据. 即: get是从服务器上获取数据，post是向服务器传送数据
- get请求可以将查询字符串参数追加到url的末尾，有长度限制; post请求应该把数据作为请求的主体提交. 其请求主体可以包含非常多的数据, 而且格式不限
- 因为get请求提交的数据直接加载url末尾,所以其大小有限制; 理论来讲, post是没有大小限制的
- post安全性比get要高(post方法请求是封装在http消息包体中)
- 对于get方式, 服务器端用Request.QueryString获取变量的值
- 对于post方式, 服务器端用Request.Form获取提交的数据

&|get|post
---|---|----
后退/刷新|无害|请求重新提交
书签|可做书签|不可做
缓存|可被缓存|不能被缓存
历史|保留在浏览器记录里|不保留
对数据长度限制|限制（2048字符）|不限制
安全性|url中暴露数据|相对安全
可见性|url中可见|不可见

## 状态码

### HTTP状态码分类

| 分类 | 分类描述 |
| --- | --- |
| 1×× | 信息，服务器收到请求，需要请求者继续操作 |
| 2×× | 成功，操作被成功接收并处理 |
| 3×× | 重定向，需要进一步的操作以完成请求 |
| 4×× | 客户端错误，请求包含语法错误或无法完成请求 |
| 5×× | 服务器错误，服务器在请求的过程中发生了错误 |

### HTTP状态码列表 |

| 状态码 | 状态码英文名称 | 中文描述 |
| --- | --- | --- |
| 101 | Switching Protocols | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
| 200 | OK | 请求成功。一般用于GET与POST请求 |
| 201 | Created | 已创建。成功请求并创建了新的资源 |
| 202 | Accepted | 已接受。已经接受请求，但未处理完成 |
| 203 | Non-Authoritative Information | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204 | No Content | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205 | Reset Content | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206 | Partial Content | 部分内容。服务器成功处理了部分GET请求 |
| 300 | Multiple Choices | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301 | Moved Permanently | 永久移动。重定向 |
| 302 | Found | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
| 303 | See Other | 查看其它地址。与301类似。使用GET和POST请求查看 |
| 304 | Not Modified | 未修改。所请求的资源未修改，直接从缓存返回资源 |
| 305 | Use Proxy | 使用代理。所请求的资源必须通过代理访问 |
| 306 | Unused | 已经被废弃的HTTP状态码 |
| 307 | Temporary Redirect | 临时重定向。与302类似。使用GET请求重定向 |
| 400 | Bad Request | 客户端请求的语法错误，服务器无法理解 |
| 401 | Unauthorized | 请求要求用户的身份认证 |
| 402 | Payment Required | 保留，将来使用 |
| 403 | Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404 | Not Found | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405 | Method Not Allowed | 客户端请求中的方法被禁止 |
| 406 | Not Acceptable | 服务器无法根据客户端请求的内容特性完成请求 |
| 407 | Proxy Authentication Required | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408 | Request Time-out | 服务器等待客户端发送的请求时间过长，超时 |
| 409 | Conflict | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 |
| 410 | Gone | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411 | Length Required | 服务器无法处理客户端发送的不带Content-Length的请求信息 |
| 412 | Precondition Failed | 客户端请求信息的先决条件错误 |
| 413 | Request Entity Too Large | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414 | Request-URI Too Large | 请求的URI过长（URI通常为网址），服务器无法处理 |
| 415 | Unsupported Media Type | 服务器无法处理请求附带的媒体格式 |
| 416 | Requested range not satisfiable | 客户端请求的范围无效 |
| 417 | Expectation Failed | 服务器无法满足Expect的请求头信息 |
| 500 | Internal Server Error | 服务器内部错误，无法完成请求 |
| 501 | Not Implemented | 服务器不支持请求的功能，无法完成请求 |
| 502 | Bad Gateway | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 |
| 503 | Service Unavailable | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504 | Gateway Time-out | 充当网关或代理的服务器，未及时从远端服务器获取请求 |
| 505 | HTTP Version not supported | 服务器不支持请求的HTTP协议的版本，无法完成处理 |

## 协议版本

### Http 1.0 与 1.1区别

- 1.0 对于每个连接都得建立一次连接, 一次只能传送一个请求和响应, 请求就会关闭
- 1.1 在同一个连接中可以传送多个请求和响应, 多个请求可以重叠和同时进行
- 1.1中引入了ETag头, 它的值entity tag可以用来唯一的描述一个资源. 请求消息中可以使用If-None-Match头域来匹配资源的entitytag是否有变化
- 1.1 新增了Cache-Control头域(消息请求和响应请求都可以使用), 它支持一个可扩展的指令子集
- 1.0中只定义了16个状态响应码, 对错误或警告的提示不够具体. http1.1引入了一个Warning头域, 增加对错误或警告信息的描述. 且新增了24个状态响应码

### Http1.1和Http2之间的区别

1. HTTP/2采用二进制格式化而非文本格式
1. HTTP/2是完全的多路复用，只需要一个链接即可实现并行
1. 使用报头压缩，降低了开销
1. 让服务器可以将 响应 主动推送到客户端缓存中

## HTTPS详解

相比HTTP多了个S，其实指的是应用层和传输层中间的TLS/SSL的加密

### TLS / SSL

全称Transport Layer Security和他的前身 SSL（Secure Sockets Layer）都是一种安全协议，旨在为互联网通信传输提供安全及数据完整性保障

#### SSL

SSL包括记录层与传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）

这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听

#### TLS

连接建立流程：

- 客户端连接到支持TLS协议的服务器，并列出支持的密码组合（加密密码算法+加密哈希算法），第一次握手开始
- 服务器从该列表中决定加密和散列函数，并通知客户端
- 服务器发回数字证书（包含服务器名称，CA证书与公钥）
- 客户端验证证书有效性
- 客户端使用服务器发回的公钥加密随机生成的密钥，发送到服务器，只有服务器的私钥才能解密
- 利用随机数，双方生成用于加密和解密的对称密钥

### 不加密可能存在的风险

- 窃听风险
- 篡改风险
- 冒充风险
